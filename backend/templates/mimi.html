<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mimi.Today</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/styles.css">
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <script defer src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js"></script>
  <script>
    // Set theme before page renders to prevent flash
    document.documentElement.setAttribute('data-theme', localStorage.getItem('mimi-theme') || 'solid');
  </script>
  <style>
    .theme-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      background: var(--bg-card);
      border: none;
      border-radius: 20px;
      padding: 6px 12px;
      color: var(--text-muted);
      font-size: 0.75rem;
      cursor: pointer;
      z-index: 50;
      transition: all 0.2s ease;
    }
    .theme-toggle:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }
    .date-nav {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
    .nav-btn {
      background: var(--bg-card);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      color: var(--text-muted);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .nav-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    .nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .task-card.readonly {
      cursor: default;
      opacity: 0.85;
    }
    .task-card.readonly:hover {
      transform: none;
    }
    .date-label {
      text-align: center;
      min-width: 200px;
    }
    .date-label h1 {
      font-size: 1.5rem;
      margin: 0;
    }
    .date-label .today-badge {
      font-size: 0.75rem;
      color: var(--color-completed);
      margin-top: 4px;
    }
  </style>
</head>
<body x-data="taskApp()" @scroll.window="checkRefresh">
  <!-- Theme toggle -->
  <button class="theme-toggle" @click="toggleTheme()" x-text="theme === 'dark' ? '◐ Solid' : '◑ Dark'"></button>
  
  <div class="container">
    <header class="header">
      <div class="date-nav">
        <button class="nav-btn" @click="prevDay()" title="Previous day">&larr;</button>
        <div class="date-label">
          <h1 x-text="displayDateFormatted"></h1>
          <div class="today-badge" x-show="isToday">Today</div>
        </div>
        <button class="nav-btn" @click="nextDay()" :disabled="isToday" title="Next day">&rarr;</button>
      </div>
    </header>

    <!-- Task list -->
    <div class="task-list" id="task-list">
        <template x-for="task in tasks" :key="task.id">
        <div 
          class="task-card"
          :class="{
            'required': task.priority === 'required' && task.status !== 'completed',
            'optional': task.priority === 'optional' && task.status !== 'completed',
            'completed': task.status === 'completed',
            'just-completed': task.justCompleted,
            'readonly': !isToday
          }"
          :style="`min-height: ${Math.max(60, task.expected_minutes * 1.5)}px`"
          @click="toggleTask(task)"
        >
          <div class="task-content">
            <div class="task-checkbox">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <polyline points="20 6 9 17 4 12"></polyline>
              </svg>
            </div>
            <div class="task-info">
              <div class="task-title" x-text="task.title"></div>
            </div>
            <span 
              class="task-badge"
              :class="{
                'required': task.priority === 'required' && task.status !== 'completed',
                'done': task.status === 'completed'
              }"
              x-show="task.status === 'completed' || task.priority === 'required'"
              x-text="task.status === 'completed' ? 'Done!' : 'Required'"
            ></span>
          </div>
        </div>
      </template>

      <!-- Empty state -->
      <div class="empty-state" x-show="tasks.length === 0">
        <p x-text="isToday ? 'No tasks for today' : 'No tasks for this day'"></p>
      </div>
    </div>
  </div>

  <script>
    function taskApp() {
      return {
        tasks: [],
        theme: localStorage.getItem('mimi-theme') || 'solid',
        audioCtx: null,
        displayDate: new Date(),
        
        get displayDateFormatted() {
          return this.displayDate.toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
        },
        
        get isToday() {
          const today = new Date();
          return this.displayDate.toDateString() === today.toDateString();
        },
        
        get displayDateStr() {
          // Format as YYYY-MM-DD for API
          return this.displayDate.toISOString().split('T')[0];
        },
        
        prevDay() {
          const newDate = new Date(this.displayDate);
          newDate.setDate(newDate.getDate() - 1);
          this.displayDate = newDate;
          this.loadTasks();
        },
        
        nextDay() {
          if (this.isToday) return; // Can't go beyond today
          const newDate = new Date(this.displayDate);
          newDate.setDate(newDate.getDate() + 1);
          this.displayDate = newDate;
          this.loadTasks();
        },
        
        toggleTheme() {
          this.theme = this.theme === 'dark' ? 'solid' : 'dark';
          localStorage.setItem('mimi-theme', this.theme);
          document.documentElement.setAttribute('data-theme', this.theme);
        },
        
        refreshCooldown: false,
        
        async init() {
          await this.loadTasks();
        },
        
        checkRefresh() {
          if (this.refreshCooldown) return;
          
          const scrollTop = window.scrollY;
          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = window.innerHeight;
          
          // Refresh when overscrolling top or bottom
          if (scrollTop <= 0 || scrollTop + clientHeight >= scrollHeight) {
            this.refreshCooldown = true;
            this.loadTasks();
            setTimeout(() => { this.refreshCooldown = false; }, 2000);
          }
        },
        
        async loadTasks() {
          try {
            const response = await fetch(`/api/tasks/date/${this.displayDateStr}`);
            this.tasks = await response.json();
            // Keep Ilse's order - only sort by order field
            this.tasks.sort((a, b) => a.order - b.order);
          } catch (err) {
            console.error('Failed to load tasks:', err);
          }
        },
        
        async toggleTask(task) {
          // Only allow toggling on today's tasks
          if (!this.isToday) return;
          
          const wasCompleted = task.status === 'completed';
          const endpoint = wasCompleted 
            ? `/api/tasks/${task.id}/uncomplete`
            : `/api/tasks/${task.id}/complete`;
          
          try {
            const response = await fetch(endpoint, { method: 'POST' });
            const updated = await response.json();
            
            // Update task in list
            const idx = this.tasks.findIndex(t => t.id === task.id);
            if (idx !== -1) {
              this.tasks[idx] = { ...updated, justCompleted: !wasCompleted };
              
              // Play sound and haptic on completion
              if (!wasCompleted) {
                this.playDing();
                this.vibrate();
                // Remove animation class after animation
                setTimeout(() => {
                  this.tasks[idx].justCompleted = false;
                }, 500);
              }
              // Don't re-sort - keep Ilse's order
            }
          } catch (err) {
            console.error('Failed to toggle task:', err);
          }
        },
        
        vibrate() {
          // Short haptic feedback if supported
          if (navigator.vibrate) {
            navigator.vibrate(50);
          }
        },
        
        getAudioContext() {
          // Reuse audio context to prevent browser limitations
          if (!this.audioCtx || this.audioCtx.state === 'closed') {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          // Resume if suspended (happens after browser tab is inactive)
          if (this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
          }
          return this.audioCtx;
        },
        
        playDing() {
          try {
            const audioCtx = this.getAudioContext();
            
            // Main tone - A5
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.frequency.value = 880; // A5 - warm and pleasant
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.5);
            
            // Harmonic for richness - E6
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            osc2.frequency.value = 1320; // E6
            osc2.type = 'sine';
            gain2.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc2.start(audioCtx.currentTime);
            osc2.stop(audioCtx.currentTime + 0.3);
          } catch (e) {
            console.warn('Audio playback failed:', e);
          }
        }
      };
    }
  </script>
</body>
</html>

