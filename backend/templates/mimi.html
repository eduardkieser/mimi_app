<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mimi.Today</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/styles.css">
  <script src="https://unpkg.com/htmx.org@1.9.10"></script>
  <script defer src="https://unpkg.com/alpinejs@3.13.3/dist/cdn.min.js"></script>
  <script>
    // Set theme before page renders to prevent flash
    document.documentElement.setAttribute('data-theme', localStorage.getItem('mimi-theme') || 'dark');
  </script>
  <style>
    .theme-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      background: var(--bg-card);
      border: none;
      border-radius: 20px;
      padding: 6px 12px;
      color: var(--text-muted);
      font-size: 0.75rem;
      cursor: pointer;
      z-index: 50;
      transition: all 0.2s ease;
    }
    .theme-toggle:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }
    .header .date {
      font-size: 1.8rem;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }
  </style>
</head>
<body x-data="taskApp()" @scroll.window="checkRefresh">
  <!-- Theme toggle -->
  <button class="theme-toggle" @click="toggleTheme()" x-text="theme === 'dark' ? '◐ Solid' : '◑ Dark'"></button>
  
  <div class="container">
    <header class="header">
      <h1 class="date" x-text="todayFormatted"></h1>
    </header>

    <!-- Task list -->
    <div class="task-list" id="task-list">
        <template x-for="task in tasks" :key="task.id">
        <div 
          class="task-card"
          :class="{
            'required': task.priority === 'required' && task.status !== 'completed',
            'optional': task.priority === 'optional' && task.status !== 'completed',
            'completed': task.status === 'completed',
            'just-completed': task.justCompleted
          }"
          :style="`min-height: ${Math.max(60, task.expected_minutes * 1.5)}px`"
          @click="toggleTask(task)"
        >
          <div class="task-content">
            <div class="task-checkbox">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <polyline points="20 6 9 17 4 12"></polyline>
              </svg>
            </div>
            <div class="task-info">
              <div class="task-title" x-text="task.title"></div>
            </div>
            <span 
              class="task-badge"
              :class="{
                'required': task.priority === 'required' && task.status !== 'completed',
                'optional': task.priority === 'optional' && task.status !== 'completed',
                'done': task.status === 'completed'
              }"
              x-text="task.status === 'completed' ? 'Done!' : task.priority"
            ></span>
          </div>
        </div>
      </template>

      <!-- Empty state -->
      <div class="empty-state" x-show="tasks.length === 0">
        <p>No tasks for today</p>
      </div>
    </div>
  </div>

  <script>
    function taskApp() {
      return {
        tasks: [],
        theme: localStorage.getItem('mimi-theme') || 'dark',
        audioCtx: null,
        
        get todayFormatted() {
          return new Date().toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
        },
        
        toggleTheme() {
          this.theme = this.theme === 'dark' ? 'solid' : 'dark';
          localStorage.setItem('mimi-theme', this.theme);
          document.documentElement.setAttribute('data-theme', this.theme);
        },
        
        refreshCooldown: false,
        
        async init() {
          await this.loadTasks();
        },
        
        checkRefresh() {
          if (this.refreshCooldown) return;
          
          const scrollTop = window.scrollY;
          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = window.innerHeight;
          
          // Refresh when overscrolling top or bottom
          if (scrollTop <= 0 || scrollTop + clientHeight >= scrollHeight) {
            this.refreshCooldown = true;
            this.loadTasks();
            setTimeout(() => { this.refreshCooldown = false; }, 2000);
          }
        },
        
        async loadTasks() {
          try {
            const response = await fetch('/api/tasks/today');
            this.tasks = await response.json();
            // Keep Ilsa's order - only sort by order field
            this.tasks.sort((a, b) => a.order - b.order);
          } catch (err) {
            console.error('Failed to load tasks:', err);
          }
        },
        
        async toggleTask(task) {
          const wasCompleted = task.status === 'completed';
          const endpoint = wasCompleted 
            ? `/api/tasks/${task.id}/uncomplete`
            : `/api/tasks/${task.id}/complete`;
          
          try {
            const response = await fetch(endpoint, { method: 'POST' });
            const updated = await response.json();
            
            // Update task in list
            const idx = this.tasks.findIndex(t => t.id === task.id);
            if (idx !== -1) {
              this.tasks[idx] = { ...updated, justCompleted: !wasCompleted };
              
              // Play sound and haptic on completion
              if (!wasCompleted) {
                this.playDing();
                this.vibrate();
                // Remove animation class after animation
                setTimeout(() => {
                  this.tasks[idx].justCompleted = false;
                }, 500);
              }
              // Don't re-sort - keep Ilsa's order
            }
          } catch (err) {
            console.error('Failed to toggle task:', err);
          }
        },
        
        vibrate() {
          // Short haptic feedback if supported
          if (navigator.vibrate) {
            navigator.vibrate(50);
          }
        },
        
        getAudioContext() {
          // Reuse audio context to prevent browser limitations
          if (!this.audioCtx || this.audioCtx.state === 'closed') {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          // Resume if suspended (happens after browser tab is inactive)
          if (this.audioCtx.state === 'suspended') {
            this.audioCtx.resume();
          }
          return this.audioCtx;
        },
        
        playDing() {
          try {
            const audioCtx = this.getAudioContext();
            
            // Main tone - brighter C7
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.frequency.value = 2093; // C7 - bright and clear
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.3);
            
            // Harmonic for sparkle - G7
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            osc2.frequency.value = 3136; // G7
            osc2.type = 'sine';
            gain2.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc2.start(audioCtx.currentTime);
            osc2.stop(audioCtx.currentTime + 0.2);
          } catch (e) {
            console.warn('Audio playback failed:', e);
          }
        }
      };
    }
  </script>
</body>
</html>

